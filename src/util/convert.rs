use crate::server::server::db_connection::*;
use crate::server::server::db_connection::cell_value::CellType::*;
use super::valuetype::ValueType;

/* The types generated by Prost aren't ideal. These help fix that. */
pub fn to_connect_result(id: String) -> ConnectResult {
    ConnectResult { id }
}

pub fn to_query_result(column_names: Vec<String>, row_values: Vec<Vec<ValueType>>) -> QueryResult {
    QueryResult {
        column_names,
        row_values: row_values.into_iter().map(to_row_value).collect(),
    }
}

pub fn to_update_result(success: bool, message: String) -> UpdateResult {
    UpdateResult { success, message }
}

pub fn to_row_value(row_values: Vec<ValueType>) -> RowValue {
    RowValue {
        cell_values: row_values.into_iter().map(to_value).collect(),
    }
}

pub fn to_value(value: ValueType) -> CellValue {
    match value {
        ValueType::ValString(s) => CellValue {
            cell_type: Some(ColString { 0: s }),
        },
        ValueType::ValI32(i) => CellValue {
            cell_type: Some(ColI32 { 0: i }),
        },
        ValueType::ValFloat(f) => CellValue {
            cell_type: Some(ColFloat { 0: f }),
        },
        ValueType::ValTimestamp(t) => CellValue {
            cell_type: Some(ColTime { 0: t }),
        },
        ValueType::ValI64(i) => CellValue {
            cell_type: Some(ColI64 { 0: i }),
        },
        ValueType::ValDouble(d) => CellValue {
            cell_type: Some(ColDouble { 0: d }),
        },
        ValueType::ValBool(b) => CellValue {
            cell_type: Some(ColBool { 0: b }),
        },
    }
}

pub fn from_row_value(row_value: RowValue) -> Vec<ValueType> {
    row_value
        .cell_values
        .into_iter()
        .map(from_value)
        .collect::<Vec<ValueType>>()
}

pub fn from_value(value: CellValue) -> ValueType {
    match value.cell_type.unwrap() {
        ColString { 0: s } => ValueType::ValString(s),
        ColI32 { 0: i } => ValueType::ValI32(i),
        ColFloat { 0: f } => ValueType::ValFloat(f),
        ColTime { 0: t } => ValueType::ValTimestamp(t),
        ColI64 { 0: i } => ValueType::ValI64(i),
        ColDouble { 0: d } => ValueType::ValDouble(d),
        ColBool { 0: b } => ValueType::ValBool(b),
    }
}